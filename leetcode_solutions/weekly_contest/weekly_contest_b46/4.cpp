#include "utils.h"

class Solution {
    #define X 1000
    //结点记录自己的祖先中，离自己最近的点
    //比如near[9]表示自己的祖先里，值为9且离的最近的
    struct node{
        int near[51];
        node(){}
        node(int val){
            fill(near,near+51,val);
        }
    };
    int _level[X];
    node n[X];
    //adj[i]保存结点i的所有邻居
    vi adj[X];
    vi ans;
    #define level(i) (i>=0?_level[i]:-1)
    void traverse(int cur,int parent,vi&nums){
        int near=-1;
        for(int i=1;i<=50;i++){
            if(gcd(i,nums[cur])==1&&level(n[cur].near[i])>level(near)){
                near=n[cur].near[i];
            }
        }
        ans[cur]=near;
        n[cur].near[nums[cur]]=cur;
        for(auto child:adj[cur]){
            if(child==parent)continue;
            n[child]=n[cur];
            _level[child]=_level[cur]+1;
            traverse(child,cur,nums);
        }
    }
public:
    //本题要进行每个点向根的溯源的话，必然超时。所以必然要利用好从父结点传来的信息
    vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {
        for(auto&edge:edges){
            int i=edge[0],j=edge[1];
            adj[i].pb(j);
            adj[j].pb(i);
        }
        ans.resize(nums.size());
        //结点0作为根，没有任何祖先，所以默认都为-1
        n[0]=node(-1);
        _level[0]=1;
        //无向连通无环图，从某点出发进行dfs，就相当于进行树的遍历，但切忌从子结点返回父结点，所以要保存父结点编号
        traverse(0,-1,nums);
        return ans;
    }
};

int main()
{
    cout<<boolalpha;
    Solution sol;

    vi nums{18,10,23,47,11,20,7,44,14,43,43,42,2,23,5,31,18,40,49,27,50,21,19,35,23,30,31,8,7,50,7,11,4,43,1,5,24,44,24,25,24,19,48,5,37,13,50,6,20,38,43,45,34,15,42,41,5,44,16,21,26,31,12,35,13,36,2,21,29,36,7,24,1,37,40,6,19,30,12,42,30,50,20,15,34,36,49,2,34,36,38,8,11,33,46,19,24,41,2,31,14,32,9,29,12,6,45,47,32,24,37,4,25,50,24,10,31,40,5,12,22,7,23,2,27,42,8,6,1,15,16,32,32,38,29,24,33,22,33,29,17};
    vvi edges=makevvi("[[57,0],[5,57],[76,5],[85,76],[46,85],[127,85],[25,0],[114,25],[7,114],[45,114],[100,25],[122,100],[17,122],[12,17],[48,100],[40,48],[60,40],[88,48],[108,48],[10,108],[11,10],[121,11],[9,121],[109,11],[111,109],[91,109],[118,91],[53,118],[26,53],[47,26],[126,47],[133,109],[123,133],[59,123],[81,48],[31,81],[15,31],[24,15],[132,81],[119,132],[21,119],[63,81],[128,63],[73,128],[34,63],[72,34],[38,72],[97,72],[3,97],[30,3],[13,30],[80,13],[33,80],[66,80],[102,66],[8,80],[77,8],[79,77],[42,79],[19,42],[78,19],[20,78],[55,79],[37,55],[49,37],[89,49],[36,89],[83,89],[95,49],[64,95],[28,64],[32,28],[92,32],[93,92],[86,93],[39,86],[87,39],[2,87],[134,93],[135,49],[110,3],[29,110],[52,29],[136,29],[99,136],[50,99],[84,50],[56,84],[51,99],[112,51],[101,112],[41,29],[74,41],[103,74],[129,74],[6,129],[137,129],[61,29],[104,61],[131,104],[58,104],[14,58],[18,14],[138,18],[117,138],[125,138],[106,125],[120,18],[130,120],[124,130],[62,124],[82,62],[4,62],[113,4],[139,130],[1,104],[67,1],[70,1],[43,70],[96,70],[98,96],[69,98],[94,69],[115,94],[75,1],[44,75],[68,44],[16,68],[54,68],[65,68],[27,65],[71,65],[105,65],[35,105],[107,65],[116,65],[90,116],[23,90],[140,1],[22,140]]");
    auto ans=sol.getCoprimes(nums,edges);
    DBGV(ans);

    system("pause");
    return 0;
}
