#include "utils.h"

class Solution {
    #define X 100000
    //结点记录自己的祖先中，离自己最近的点
    //比如near[9]表示自己的祖先里，值为9且离的最近的
    struct node{
        int near[51];
        node(){}
        node(int val){
            fill(near,near+51,val);
        }
    };
    int _level[X];
    node n[X];
    //adj[i]保存结点i的所有邻居
    vi adj[X];
    vi ans;
    #define level(i) (i>=0?_level[i]:-1)
    void traverse(int cur,int parent,vi&nums){
        int near=-1;
        for(int i=1;i<=50;i++){
            if(gcd(i,nums[cur])==1&&level(n[cur].near[i])>level(near)){
                near=n[cur].near[i];
            }
        }
        ans[cur]=near;
        n[cur].near[nums[cur]]=cur;
        for(auto child:adj[cur]){
            if(child==parent)continue;
            n[child]=n[cur];
            _level[child]=_level[cur]+1;
            traverse(child,cur,nums);
        }
    }
public:
    //本题要进行每个点向根的溯源的话，必然超时。所以必然要利用好从父结点传来的信息
    vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {
        for(auto&edge:edges){
            int i=edge[0],j=edge[1];
            adj[i].pb(j);
            adj[j].pb(i);
        }
        ans.resize(nums.size());
        //结点0作为根，没有任何祖先，所以默认都为-1
        n[0]=node(-1);
        _level[0]=1;
        //无向连通无环树，从某点出发进行dfs，就相当于进行树的遍历，但切忌从子结点返回父结点，所以要保存父结点编号
        traverse(0,-1,nums);
        return ans;
    }
};

int main()
{
    cout<<boolalpha;
    Solution sol;

    vi nums{36,49,26,50,23,41,1,33,7,8,26,14,43,49,21,36,2,11,33,8,34,20,11,12,39,46,4,47,31,33,38,39,13,14,1,5,4,44,3,13,25,34,2,40,35,4,13,37,12,26,27,5,7,1,42,44,41,43,43,8,50,8,44,40,11,1,17,34,25,8,14,9,19,6,44,38,49,50,27,50,25,10,1,41,30,5,26,38,6,48,40,13,11,44,44,14,48,16,3,24,4,26,36,7,35,50,34,32};
    vvi edges{
        {99,0},{64,99},{91,64},{55,91},{94,0},{37,94},{58,37},{10,58},{6,10},{56,10},{45,56},{36,45},{40,45},{49,56},{101,49},{39,37},{69,39},{30,69},{34,30},{71,39},{98,39},{31,98},{22,31},{102,22},{3,98},{107,3},{50,107},{18,50},{16,18},{85,107},{15,85},{67,107},{42,67},{72,67},{12,67},{79,12},{53,79},{41,53},{68,53},{59,53},{78,59},{5,59},{105,5},{103,105},{24,79},{70,24},{4,70},{33,70},{54,70},{13,70},{46,13},{74,46},{93,74},{90,93},{1,90},{32,1},{52,1},{38,90},{57,38},{95,90},{14,95},{75,14},{66,75},{97,95},{2,97},{86,97},{25,97},{100,25},{61,100},{8,61},{104,93},{80,104},{82,104},{19,74},{81,19},{62,81},{87,81},{48,87},{77,48},{51,77},{7,81},{63,7},{27,63},{26,63},{28,26},{84,7},{11,84},{20,7},{89,20},{92,20},{76,92},{44,92},{83,44},{65,19},{47,65},{60,47},{23,60},{43,23},{21,43},{17,21},{35,23},{9,35},{29,9},{73,29},{88,60},{96,65},{106,19}
    };
    auto ans=sol.getCoprimes(nums,edges);
    DBGV(ans);

    system("pause");
    return 0;
}
